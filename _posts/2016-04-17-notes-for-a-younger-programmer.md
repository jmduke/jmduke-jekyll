---
title: "Notes for a younger programmer"
Date: 2016-04-17 00:00:00
tags: star
layout: post
---

<p>(A living document.)</p>


<p>If you are faced with a question to which you don’t know the answer, spend fifteen minutes looking for the answer yourself.  Then ask someone else.</p>


<p>There is no shame in asking questions.</p>


<p>There is a great deal of shame in being too proud to ask questions.</p>


<p>Always leave a codebase cleaner than you found it — whether it’s adding documentation, cleaning up syntax, or fixing an edge case.  Someone will be grateful, even if that someone is Future You.</p>


<p>Tests deserve comments, too.</p>


<p>Decide what you’re willing to leave at work.  Stick to it.</p>


<p>The best way to improve as a programmer is to program; the best way to improve as a software developer is to use software.</p>


<p>Never forget that one can use software by reading it.</p>


<p>Don’t treat code reviews or design critiques as a adversarial process; recognize that its a cooperative effort to refine artifacts into their best possible form.</p>


<p>Assume that everyone has the best intentions.  Even if they don’t, it’ll make your life easier.</p>


<p>When debating an issue, ask yourself “how much do I really care about this?”  Otherwise, you will inevitably spend time and energy debating whether something should be named <code>FooWidgetProcessor</code> or <code>FooWidgetHandler</code>.</p>


<p>Sometimes, though, it’s important to decide whether or not something should be <code>FooWidgetProcessor</code> versus <code>FooWidgetHandler</code>.  Naming is important; conventions are important.</p>


<p>Communication is a more important skill than code.  Be cautious of anyone or anything that implies otherwise.</p>


<p>Take enough pride in your work to be happy when it succeeds but not enough to be destroyed when it fails.</p>


<p>Your stuff will fail, like, a lot.  The test data won’t be extensive enough; there will be an edge case you missed; you will miss a use case; your work will not be resilient enough or robust enough or gracious enough.  Don’t think less of yourself for it; learning through error is still learning.</p>


<p>In ascending order of robustness: thought, conversation, email, documentation, code.</p>


<p>Optimize for robustness.</p>


<p>All documents are living documents.</p>


<p>Don’t confuse reliability with uptime.</p>


<p>Everything happened for a reason, even if it’s that six-year-old cron job that checks for emails containing the word “yes”, and even if the reason was “we had to ship this feature in two days.”  Pretending that past developers are incorrigible bogeymen is only going to cause you more grief.</p>


<p>“Boring” is a better heuristic for code quality than “clever”.</p>


<p>All code is technical debt.  Even if its a CLI that you think you’ll use for a one-off job and then delete; even if its a ‘stop-gap measure’.  (Stop-gap measures stop being stop-gap measures as soon as they’re promoted to prod, at which point they become the status quo.)</p>


<p>You make what you measure.  Invest a lot of time in making sure that you’re measuring the right things.</p>


<p>Everyone knows some things better than you and some things worse than you.  Investing too much in either is a bad idea.</p>


<p>There is no shame in investing in your tools.</p>


<p>Consider everything that helps you work as a tool: your language, your code conventions, your IDE, your headphones, your chair, your iTerm font, your desktop background, your coffee.</p>


<p>Help as many people as possible.</p>
	